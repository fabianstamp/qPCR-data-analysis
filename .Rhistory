knitr::opts_chunk$set(echo = TRUE)
library(readxl) # the readxl is used to import data from excel (.xlsx)
library(tidyverse) # data wrangling
library(ggpubr) # required for stat_compare_means()
library(rstatix)  # https://github.com/kassambara/rstatix
library(stats) # required for padjust() function
library(car) # required for leveneTest() function
library(kableExtra) # scrollable tables in rendered html report
ID = "Experiment ID"
Details = "Brain WT vs KO"
condition_levels <- c("WT", "KO") #set order of levels
HK1 = "reference_gene_1" #reference gene 1
HK2 = "reference_gene_2" #reference gene 2
HK <- c("reference_gene_1","reference_gene_2")  # vector of both reference genes
# Path to the qPCR_data.xlsx file
path <- file.path("..", "data", "qPCR_data.xlsx")
Ct_values <-
read_excel(path, sheet = "data", skip = 0) %>%  # import sheet "data"
dplyr::select("Well Position", "CT") %>%  # only select columns required for the analysis   # replace NA values
mutate(CT = as.numeric(CT)) %>%  # set Ct as numeric
mutate(CT = replace(CT, is.na(CT), "")) # replace NA values
genes <-
read_excel(path, sheet = "genes", col_names = paste0("V", 1:24)) %>% # import sheet 1 and add provisional column headers
mutate(row = LETTERS[1:16]) %>% # 16 rows: add the Letters to create positional information
pivot_longer(cols = c(1:24)) %>% # 24 columns
mutate(name = substring(name, 2)) %>% # This will create a positional coding, replacing the name "V" with a number
mutate("Well Position" = paste(row, name, sep = ""), # Create a new ""Well Position"" column by pasting the values of the row and name columns together
Gene = value) %>% # Create a "Gene" column, that contains values
select("Well Position", Gene) %>%  # Select columns
replace(is.na(.), "") %>%  # replace NA values
dplyr::mutate(Gene = factor(Gene))  # convert Gene to factor
#head(genes)
condition  <-
read_excel(path,
sheet = "condition",
col_types = "text",
col_names = TRUE) %>%   # import sheet "condition"
mutate(Condition = factor(Condition, levels = condition_levels)) # define "Condition" as factor and set levels
#head(Condition, n = 3)
samples <-
read_excel(
path,
sheet = "samples",
col_types = "text",
col_names = paste0("V", 1:24)
) %>% # import sheet "samples" and add provisional column headers
mutate(row = LETTERS[1:16]) %>% # 16 rows: add the Letters to create positional information
pivot_longer(cols = c(1:24)) %>% # 24 columns
mutate(name = substring(name, 2)) %>% # This will create a positional coding, replacing the name "V" with a number
mutate("Well Position" = paste(row, name, sep = ""),
# Create a new ""Well Position"" column by pasting the values of the row and name columns together
Sample = value) %>%  # Create a "Sample" column, that contains values
select("Well Position", Sample) %>%   # Select columns
replace(is.na(.), "") %>%  # replace NA values
dplyr::mutate(Sample = factor(Sample))  # convert "Sample" to factor
#head(samples, n = 3)
replicates <-
read_excel(
path,
sheet = "replicates",
col_types = "text",
col_names = paste0("V", 1:24)
) %>% # import sheet "replicates" and add provisional column headers
mutate(row = LETTERS[1:16]) %>% # 16 rows: add the Letters to create positional information
pivot_longer(cols = c(1:24)) %>% # 24 columns.
mutate(name = substring(name, 2)) %>%  # This will create a positional coding, replacing the name "V" with a number
mutate("Well Position" = paste(row, name, sep = ""),
# Create a new ""Well Position"" column by pasting the values of the row and name columns together
Replicates = value) %>% # Create a "Replicate" column, that contains the  "value" values
select("Well Position", Replicates) %>%
replace(is.na(.), "") %>%  # replace NA values
dplyr::mutate(Replicates = factor(Replicates))  # convert "Replicates" to factor
#head(replicates, n = 3)
df <- merge(Ct_values, samples, by="Well Position") %>%
merge(genes, by="Well Position") %>%
merge(replicates, by = "Well Position") %>%
merge(condition, by = "Sample") %>%
filter(!CT == "Undetermined") %>%  # remove all undetermined wells
mutate(CT = as.numeric(CT)) %>% # define CT as numeric
filter(Sample != "NTP")  # drop NTP wells
#head(df, n = 3)
Ct_plot <- df %>%
ggplot(aes(Sample, CT, fill = Gene)) +
geom_boxplot(alpha = 0.5) +
geom_point(aes(fill = Gene), shape = 21,
size = 1) +
facet_wrap(Gene ~ Condition,
scales = "free") + # split plot
labs(x = "Sample", y = "CT") + #Axis labels
ggtitle("CT values") + #Title
theme(plot.title = element_text(hjust = 0.5)) + #Center title
theme(legend.position = "right") + # position of legend
theme_classic() + # classic theme
theme(plot.title = element_text(size = 20, face = "bold"))    # increase title size
# set font size for facet label titles
# Save the plot
ggsave(
"Ct_plot.pdf",
plot = Ct_plot,
device = "pdf",
path = "../output/plots",
scale = 1,
units = "cm",
dpi = 300,
limitsize = TRUE,
)
#print to screen
print(Ct_plot)
df1 <- df %>%
select(Sample, Gene, CT, Condition) %>% # columns of interest
group_by(Gene, Sample, Condition) %>% # group values by Gene, Sample and Condition
summarize(CT = mean(CT, na.rm = T)) %>% # use the summarize function (with z) to calculate the mean CT - overwriting the CT column. Remove NA values, since it stops the function from working
pivot_wider(
id_cols = c(Sample, Condition),
names_from = Gene,
values_from = CT
) # restructure the data frame to enable easy data manipulation
df2 <- df1 %>%
gather(Gene, CT_mean,-c(Sample, Condition, all_of(HK)))  # convert to long format
# Calculate the geometric mean of the reference genes
geo_mean <- df2 %>%  select(HK1, HK2) %>%
gather(key = Ref, value = value,-Sample) %>%
group_by(Sample) %>%
summarise(Geo_HK = exp(mean(log(value))))  # calculate geometric mean of HK genes in a new column
# join df2 with geo_mean
df3 <- df2 %>%
inner_join(geo_mean, by = "Sample") # join with table containing geometric mean
df3 <- df3 %>%
mutate(DCT = CT_mean - Geo_HK) %>%  # calculate delta CT by subtracting the geometric mean of the house keeper genes from the individual sample CT means
ungroup() %>%
group_by(Gene, Condition) %>% # Group by Gene and Condition
mutate(DCT_mean_WT = mean(DCT)) %>%  # Calculate DCT for each Condition. There might be a more elegant version to do this only for the WT animals
ungroup() %>%
group_by(Gene) %>%
mutate(DDCT = DCT - DCT_mean_WT[Condition=="WT"]) %>% # subtract the DCT of the WT animals from the DCT of the individual samples (treated sample - untreated sample)
mutate(FoldChange = 2^-(DDCT)) %>% # calculate FoldChange
mutate(Log2FoldChange = log2(FoldChange)) # Transform onto log2 scale
df3 <-df3 %>%
group_by(Condition, Gene) %>%
mutate( N = n()) %>% # Add N number
mutate(Condition_label = paste0(Condition,"\n","(N=",N,")")) %>% # add annotation for plots
mutate(Condition_label = as.factor(Condition_label)) %>%  # define annotation as factor
mutate( Experiment = as.factor(ID)) %>%
mutate(Gene_name = str_extract(Gene, "^.*?(?=_)"), .before = "Gene")  %>% # Add "clean" gene name for plotting
mutate(Gene_name = ifelse(!is.na(Gene_name), Gene_name, Gene)) %>% # Create column containing only gene name by merging Gene with Gene_name if Gene_name contains "NA" values
ungroup()
#head(df3)
#subset data frame
df_stats <- df3 %>%
select("Condition", "Log2FoldChange", "Gene")
df_sum <- df_stats %>%
group_by(Condition, Gene) %>%   # group
dplyr::summarise(
n = n(),
# how many observations
mean = round(mean(Log2FoldChange), digits = 2),
# calculate mean
sd = round(sd(Log2FoldChange), digits = 2),
#calculate sd
p_shapiro = round(shapiro.test(Log2FoldChange)$p.value, digits =
3) # Shapiro-Wilk Test for normality
) %>%
mutate(mean_sd = paste(mean, sd, sep = " \u00b1 "))  %>% # add a column containing mean and sd together, \u00b1 is the unicode for "+-"
pivot_wider(names_from = Condition,
# increase number of columns and decrease number of rows to make a nice summary table for presentation
values_from = c(n, mean, sd, p_shapiro, mean_sd))
df_sum %>%
kable("html") %>%
kable_styling() %>%
scroll_box(height = "200px")
## Define functions (levene/ t/ welch/ wilcox) that allow you to obtain the respective p-values
fun.levene.test <- function(x){
a = leveneTest(Log2FoldChange ~ Condition, data = x)
b = round(a[[3]][[1]], digits = 30)
}
fun.t.test <- function(x){
a = t.test(Log2FoldChange ~ Condition, alternative = "two.sided", var.equal = TRUE, data = x)
b = round(a[[3]], digits = 30)
}
fun.welch.test <- function(x){
a = t.test(Log2FoldChange ~ Condition, alternative = "two.sided", var.equal = FALSE, data = x)
b = round(a[[3]], digits = 30)
}
fun.wilcox.test <- function(x){
a = wilcox.test(Log2FoldChange ~ Condition, exact=FALSE, data = x)
b = round(a[[3]], digits = 30)
}
# Create a nested data frame that contains a list of lists for individual genes. Subsequently you will apply the test functions on each element (list) nested within the data frame.
df_nested <- df_stats%>%
group_by(Gene) %>%
nest()
# perform levene/ttest/welch/wilcox with each element of the nested data
df_com <- df_nested %>%
mutate(
levene = map_dbl(data, fun.levene.test),
t = map_dbl(data, fun.t.test),
welch = map_dbl(data, fun.welch.test),
wilcox = map_dbl(data, fun.wilcox.test)
)
# combine it with by columns
df_sumcom <- df_sum %>%
left_join(df_com, by = "Gene")
# Create the comparison decision tree
pipe_com_choice <- . %>%
mutate(shapiro = ifelse(p_shapiro_WT < 0.05 |
p_shapiro_KO < 0.05, "*", "n.s.")) %>%
mutate(
compare_which = case_when(
shapiro != "n.s."                 ~ "wilcox",
shapiro == "n.s." & levene > 0.05 ~ "t",
shapiro == "n.s." & levene < 0.05 ~ "welch"
)
)  %>%
mutate(
test_p = ifelse(
compare_which == "wilcox",
wilcox,
ifelse(compare_which == "t", t, welch)
),
p_star = case_when(
test_p < 0.0001 ~ "****",
test_p < 0.001 ~ "***",
test_p < 0.01 ~ "**",
test_p < 0.05 ~ "*",
test_p > 0.05 ~ "n.s."
)
)
# apply the decision tree
df_sumcom_choice <- df_sumcom %>%
pipe_com_choice()
# calculate adjusted p values with the Benjamini & Hochberg (1995) method  ("BH" or its alias "fdr")
df_sumcom_choice <-df_sumcom_choice %>%
mutate(padj = p.adjust(test_p, method = "BH"),n = length(Gene)) %>%
mutate(padj_star = case_when(padj  < 0.0001 ~ "****",
padj  < 0.001 ~ "***",
padj < 0.01 ~ "**",
padj  < 0.05 ~ "*",
padj  > 0.05 ~ "n.s."))
results_stats_final <- df_sumcom_choice %>%
select(!data) %>%
mutate(ID = ID, Details = Details, Gene_name = str_extract(Gene, "^.*?(?=_)"), .before = "Gene") %>% # Add ID and Details info. Also Create a new column witht eh gene name that does not contain the primer ending
mutate(Gene_name = ifelse(!is.na(Gene_name), Gene_name, Gene)) # Create column containing onlz gene name by merging Gene with Gene_name if Gene_name contains "NA" values
# save to table
write.csv(results_stats_final, paste("../output/tables/results_stats_final_",ID,".csv", sep = ""))
results_stats_final %>%
kable("html") %>%
kable_styling() %>%
scroll_box(height = "200px")
# Create a data frame that contains group1, group2. .y.and condition_+label
stat.test <- df_stats %>%
group_by(Gene) %>%
mutate(group1 = paste0("WT", "\n", "(N=", 6, ")")) %>% # Create column containing WT x axis labels
mutate(group2 = paste0("KO", "\n", "(N=", 6, ")")) %>% # Create column containing KO x axis labels
get_y_position(formula = Log2FoldChange ~ Condition, fun = "max") %>%  # calculate the y.position
add_x_position() %>% # add x positions 1 and 2
mutate(Condition = "KO") %>% # a Condition column is required for mapping of the statistics though it seems to not mater how it is filled.
left_join(results_stats_final, stat.testx, by = "Gene") %>% # use left_join to add the results from the manually calculated statistics
distinct(Gene, .keep_all = TRUE) # Since the merging inflated the row number which now does not match the ggplot input, you need to select a subset. This subset contains all relevant details for each gene
stat.test %>%
kable("html") %>%
kable_styling() %>%
scroll_box(height = "200px")
col <- c('#009ADC', '#FF1F5B')
theme_custom <- theme(text = element_text(family = "", size = 14),
panel.background  = element_blank(),
title = element_text(color = "#000000"),
plot.title = element_text(hjust = 0.5),
legend.text = element_text(color = "#000000"),
legend.background = element_blank(),
legend.key = element_blank(),
axis.text = element_text(color = "#000000"),
axis.line = element_line(color = "#000000"),
strip.background = element_blank(),
panel.border = element_rect(colour = "#000000", fill=NA))
all_genes_plot <- df3 %>%
ggplot(aes(x = Condition, y = Log2FoldChange, fill = Condition)) +
geom_boxplot(alpha = 0.5, width = .5) + # add box plot
scale_fill_manual(values = col) + # change colors
geom_point( # add scatter plot
shape = 21,
size = 2,
position = position_dodge(width = .75),
color = "black",
alpha = 0.5
) +
geom_hline(yintercept = 0, linetype = "dashed") + # add horizontal line indicating 0
ggtitle(paste(ID)) + # add title based on ID
facet_wrap( ~ Gene, nrow = 1) + #facet wrap by Gene
stat_summary( # calculate and add mean expression value as black diamond
fun.y = mean,
colour = "black",
geom = "point",
shape = 18,
size = 3,
position = position_dodge(width = .75),
show.legend = FALSE
) +
stat_pvalue_manual(stat.test, label = 'padj_star', tip.length = 0.01) + # add statistics
theme_custom # apply custom theme formatting
# Save the plot
ggsave(
"all_genes_plot.pdf",
plot = all_genes_plot,
device = "pdf",
path = "../output/plots",
height = 10,
width = 15,
scale = 1,
units = "cm",
dpi = 300,
limitsize = TRUE,
)
#print to screen
print(all_genes_plot)
gene_1_plot <- df3 %>%
filter(Gene == "gene_1") %>%
ggplot(aes(x = Condition_label, y = Log2FoldChange, fill = Condition)) +
geom_boxplot(alpha = 0.5, width = .5) +
scale_fill_manual(values = col) + #Change color to "col"
geom_point(
shape = 21,
size = 2,
position = position_dodge(width = .75),
color = "black",
alpha = 0.5
) +
ggtitle("Gene_1") + # Title
xlab("Condition") +
theme(
plot.title = element_text(hjust = 0.5),
# Center title
axis.text.x = element_text(
size = 10,
hjust = 0.5,
vjust = 0.5
),
axis.title = element_text(size = 15),
legend.position = "none",
strip.text = element_text(size = 10)
) + # set font size for facet label titles
stat_summary(
fun.y = mean,
colour = "black",
geom = "point",
shape = 18,
size = 3,
position = position_dodge(width = .75),
show.legend = FALSE
) +  # add the mean to the plots
stat_pvalue_manual(filter(stat.test, Gene == "gene_1"), label = 'padj_star') + # select appropriate
theme_custom # apply custom theme formatting
# Save the plot
ggsave(
"gene_1_plot.pdf",
plot = gene_1_plot,
device = "pdf",
path = "../output/plots",
height = 10,
width = 10,
scale = 1,
units = "cm",
dpi = 300,
limitsize = TRUE,
)
#print to screen
print(gene_1_plot)
sessionInfo()
